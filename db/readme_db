Expression de Besoin – device_budget

Objectif 
L’objectif est de garantir une aide à la réparation sous la forme d’un budget maximum alloué à la pièce détachée. Lorsqu’un produit est intégré dans le système THOR, le budget est calculé automatiquement en fonction des critères et de l’opérateur qui manipule l’appareil. 
Les paramètres sont updatés tant qu’ils sont en estimés. Une fois en réel, ils sont figés et historisés.


Questions en suspens
Historisation des données stats :
Est-ce qu’on crée plein de tables (une pour brande_grade + qual_grade, une pour brand + qual_grade) avec peu de champs mais tous tjrs remplis ?
Par ex dans la table avec les grades, est-ce qu’on a une ligne par grade/deviceref/jour ou une ligne par deviceref/jour et 4 champs grade (car les grades ne devraient pas trop bouger) >> Hamza plutôt option 2
Est-ce qu’on crée une seule grand table avec plein de champs mais pas tous tjrs remplis ?

Etapes de calcul
Au niveau de la référence appareil (device_ref)

Dans device_references, avoir un calcul de prix d’achat max + sale_price + methode utilisée (pour sale_price) :
Achat_prix_max  =  {[Prix de vente estimé] – SOMME [Achat_transport ; Cout_nettoyage ; Cout_log_pre ; Cout_log_post ; Cout_palette ; Cout_film ; Cout_consommableNettoyage ; Cout_SAV ; Cout_energie ; Cout_diag_est ; Marge_DN ; Cout_stockage ; Coût-pièce_avg ; Cout_rép_est]} * P(reconditionnement) - {SOMME [Achat_transport ; Cout_log_pre ; Cout_energie ; Cout_diag_est ; Cout_stockage ; Cout_démontage ; Coût-pièce ]  *[1- P(reconditionnement)]}
Pas besoin de calculer la viabilité économique au niveau deviceref car 0.
Trigger : on_update quand price_new is not null and year_production is not null and brand_id is not null and device_service_sub_category_id is not null
Autres triggers, à discuter ensemble : 
On insert to sales_import
On insert to devices
Utile si on a le timing 7j (cf plus bas), pour alléger
Bien ça et pas device_actions.type=Réception car si partenaire, device_actions.type encore inconnu au 25/09. Le but est de calculer vrt à la 1e création de l’appareil, que ce soit Doneo ou partenaire.
A discuter ensemble : Max veut toujours avec devices_refs à jour. Si je vends le modele X, update sur deviceref du modele X. Mais aussi update sur tous les deviceref ayant le meme brand_grade. Et ce script est lourd à faire tourner sur chaque ligne. Si trop lourd, idée d’avoir : 
Une table intermédiaire avec org, qual_grade, brand_grade et le calcul pour chaque, mis à jour à chaque vente >> permet d’update les devices_refs facilement si methode=2 ou 3
Si lourd, pk pas avoir un update des lignes non-updatées sur les 7 derniers jours, ce qui fait que c’est moins lourd à chaque run

Appareil – étape 1 – Calcul du budget résiduel avant Mise en Test 
Trigger :
On insert in device_actions where type=Réception, if device_references.price_new is not null and year_production is not null and brand_id is not null and device_service_sub_category_id is not null
Sinon, on edit to device_reference if price_new is not null > run for every device with this device_ref_id and device.status = ‘En attente de mise en test’
Cette étape permet d’évaluer l’intérêt de la mise en test.
Même calcul que celui fait précédemment dans devices_references, avec comme modifications :
Achat_transport dépend ici du pricing transport du lot d’achat et plus d’une moyenne.
Achat_prix_max devient Achat_prix et dépend du lot d’achat.
Budget Résiduel Pré-diag = {[Prix de vente estimé] – SOMME [Achat_prix ; Achat_transport ; Cout_nettoyage ; Cout_log_pre ; Cout_log_post ; Cout_palette ; Cout_film ; Cout_consommableNettoyage ; Cout_SAV ; Cout_energie ; Cout_diag_est ; Marge_DN ; Cout_stockage_est; Coût-pièce ; Cout_rép_est]} * P(reconditionnement) - {SOMME [Achat_prix ; Achat_transport ; Cout_log_pre ; Cout_energie ; Cout_diag_est ; Cout_stockage_est; Cout_démontage ;  Coût-pièce  ]  *[1- P(reconditionnement)]}


Appareil – étape 2 – Calcul du budget résiduel après la mise en test 
Trigger : on insert in device_actions where type=Mise en test.
Principale modif : Cout_diag_est qui se précise car on connait l’owner du diag et donc son taux horaire (from users).
Cette étape permet d’évaluer l’intérêt de poursuivre la réparation après la mise en test : 
Budget Résiduel Post-diag = {[Prix de vente estimé] – SOMME [Achat_prix ; Achat_transport ; Cout_nettoyage ; Cout_log_pre ; Cout_log_post ; Cout_palette ; Cout_film ; Cout_consommableNettoyage ; Cout_SAV ; Cout_energie ; Cout_diag_est ; Marge_DN ; Cout_stockage_est; Coût-pièce; Cout_rép_est ]} * P(reconditionnement) - {SOMME [Achat_prix ; Achat_transport;, Cout_log_pre ; Cout_energie; Cout_diag_est; Cout_stockage_est; Cout_démontage ; Coût-pièce ]  *[1- P(reconditionnement)]}

Appareil – étape 3 – Calcul du budget résiduel après diagnostic 
Trigger : on insert in device_action_reparations where status=Attente validation diagnostic
Cette étape permet d’évaluer l’intérêt de poursuivre la réparation : 
Budget Résiduel réparation = [Prix de vente estimé] – SOMME [Achat_prix ; Achat_transport ; Cout_nettoyage ; Cout_log_pre ; Cout_log_post ; Cout_palette ; Cout_film ; Cout_consommableNettoyage ; Cout_SAV ; Cout_energie ; Cout_diag_reel ; Marge_DN ; Cout_stockage_est; Coût-pièce ; Cout_rép_est] 

Etape 4.1 : Calcul de la valeur ajoutée créée si appareil réparé
Trigger : on insert in device_action_reparations where status=Terminé
Valeur ajoutée (réparée) = [Prix de vente estimé] – SOMME [Achat_prix ; Achat_transport ; Cout_nettoyage ; Cout_log_pre ; Cout_log_post ; Cout_palette ; Cout_film ; Cout_consommableNettoyage ; Cout_SAV ; Cout_energie ; Cout_diag_reel ; Marge_DN ; Cout_stockage_est; Coût-pièce; Cout_rép_reel ]

Etape 4.2 : Calcul de la valeur ajoutée créée si appareil DEEE
Trigger : on insert in device_action_reparations where status=Abandon - démontage (diagnostic) or status=Abandon - démontage (réparation)
Valeur ajoutée (DEEE) = - SOMME [Achat_prix ; Achat_transport ; Cout_nettoyage ; Cout_log_pre ; Cout_energie ; Cout_diag_reel ; Cout_stockage_est ; Cout_démontage ; Coût-pièce]  

Etape 5.1 : Calcul de la valeur ajoutée finale, post-réparation et post-vente
Trigger : on insert in device_action_reparations where status=Terminé
Valeur ajoutée (réparée) = [Prix de vente estimé] – SOMME [Achat_prix ; Achat_transport ; Cout_nettoyage ; Cout_log_pre ; Cout_log_post ; Cout_palette ; Cout_film ; Cout_consommableNettoyage ; Cout_SAV ; Cout_energie ; Cout_diag_reel ; Marge_DN ; Cout_stockage_reel ; Coût-pièce; Cout_rép_reel ]

Etape 5.2 : Calcul de la valeur ajoutée finale, post-démontage
Trigger : on insert in device_action where status=Démontage terminé
Valeur ajoutée (DEEE) = - SOMME [Achat_prix ; Achat_transport ; Cout_nettoyage ; Cout_log_pre ; Cout_energie ; Cout_diag_reel ; Cout_stockage_reel ; Cout_démontage ; Coût-pièce]  

Autres triggers
On pourrait penser qu’il faut recalculer prix_achat si update on device_references.price_new >> mais non car ce prix neuf va évoluer dans le temps, c’est normal. Pour un device donné, on considère le prix neuf saisi lors de la réception et pas un autre, ça ne bouge pas. 
On update on purchase_lot, si update on pricing or transport type or value, refaire tourner pour tous les appareils du lot, peu importe leur statut.
On insert sales_import, pour mise à jour des données device_ref (achat_prix_max, probabilités de reconditionnement).
Toutes les nuits, pour l’historique.
Ne pas refaire tourner le script pour les devices car on considère que les calculs sont faits une fois avec les chiffres dispos sur le moment et pas à refaire ensuite.

Composantes des calculs
Meme si ce n’est pas une good-practice, nous aimerions que chaque paramètre de calcul ait un champ dans la table device_actions_budget.

Calcul de la valeur de vente potentielle du produit [Prix de vente estimé]
. Se calcule sur la current_organization_id uniquement et pas sur toute la database.
. Trigger lors de la réception d’un device :
Si au moins 30 devices avec :
device.status=Vendu
and device_action_quality.quality_grade = current_device.reception_grade 
device_action_quality.quality_grade: (select daq.grade from device_actions da join da.device_id = device.id and device_actions.type=Qualité join device_action_quality daq on daq.action_id = da.id order by da.created_at desc limit 1)
current_device.reception_grade: (select dar.grade from device_actions da join da.device_id = device.id and device_actions.type=Réception join device_action_reception dar on dar.action_id = da.id order by da.created_at desc limit 1) 
and device.device_reference_id  = current_device. device_reference_id  
and organization_id=current_organization_id
and sales_invoice_import.percent_new_price >= 0.25
Prix de vente estimé = min(sales_invoice_import.percent_new_price) * price_new from device_references
Sinon si au moins 30 devices avec :
device.status=Vendu
and device_action_quality.quality_grade = current_device.reception_grade  
and brand=current_device.brand
and sales_invoice_import.percent_new_price >= 0.25
and sales_invoice_import.created_at >= 6 months ago
and organization_id=current_organization_id
Prix de vente estimé = price_new from device_references * avg(sales_invoice_import. percent_new_price)
Sinon si au moins 30 devices avec :
device.status=Vendu
and device_action_quality.quality_grade = current_device.reception_grade  
and device_service_subcartegory = current_device.device_service_subcartegory 
and sales_invoice_import.percent_new_price >= 0.25
and sales_invoice_import.created_at >= 6 months ago
and organization_id=current_organization_id
Prix de vente estimé = price_new from device_references * avg(sales_invoice_import. percent_new_price)
Sinon from sales_purchase_pricing_matrix, get row with >> pas de trigger car c’est une grille tarifaire fixe
supplier_id = device owner organization_id
and client_id join clients on client_id = clients.id where clients.name=Generic_reception and clients. owner_id = device owner organization_id
and internal_grade = current_device.reception_grade 
and age= current_device. age (current year MINUS device_ref.year_production)
and organization_id=current_organization_id
Prix de vente estimé = price_new from device_references * sales_purchase_pricing_matrix.const_percent (for the only one row found with the filters)

. Trigger par device_ref : idem sauf que le but est juste de calculer sale_price et achat_prix_max, sur chacun des 4 grades qualité. Et d’indiquer quelle méthode a été retenue.
Process : 
Bronze : faire les 3 étapes.
Calculer silver, gold et platinum sur les 3 étapes.
If silver>bronze then ok go on. Else retraitement de silver :
Si gold > bronze then silver=median(bronze,silver) et methode(silver)=99
Si gold pertinent car gold<bronze and gold>silver >> on considère que le problème provient du bronze, qui est surévalué : 
Si bronze était avec méthode 1 alors tester si bronze(methode2)<silver >>> if yes, then save this value as bronze and methode(bronze)=99. Silver does not change and methode(silver)=99.
Else if no, bronze(methode3)<silver >>> if yes, then save this value as bronze and methode(bronze)=99. Silver does not change and methode(silver)=99.
Else bronze=silver*0.9 and methode(bronze)=99. Silver does not change and methode(silver)=99.
Si gold non pertinent car gold<silver<bronze : le pb provient de silver
Test silver(methode2)>bronze. If yes, silver=silver(methode2) and methode(silver)=99.
Else if silver(methode3)>bronze. If yes, silver=silver(methode3) and methode(silver)=99.
Else silver=null and methode(silver)=99.
If gold>silver then ok go on. Else retraitement de gold:
Si platinum>silver then gold=median(silver,gold) et methode(gold)=99
Si platinum pertinent car platinum<silver and platinum>gold >> on considère que le problème provient du silver, qui est surévalué : 
Si silver était avec méthode 1 alors tester si silver(methode2)<gold >>> if yes, then save this value as silverand methode(silver)=99. gold does not change and methode(gold)=99.
Else if no, silver(methode3)<gold >>> if yes, then save this value as silverand methode(silver)=99. gold does not change and methode(gold)=99.
Else silver=gold*0.9 and methode(silver)=99. gold does not change and methode(gold)=99.
Si platinum non pertinent car platinum<gold<silver : le pb provient de gold
Test gold(methode2)>silver. If yes, gold=gold(methode2) and methode(gold)=99.
Else if gold(methode3)>silver. If yes, gold=gold(methode3) and methode(gold)=99.
Else gold=null and methode(gold)=99.
If platinum>gold then ok go on. Else retraitement de platinum :
platinum=gold*1.1
methode(platinum)=99
>> calcul d’achat_prix_max et insert into devices_references : sale_price, max_purchase_price et method_calculation, pour chacun des grades (12 champs).

Achat_prix 
A partir du lot d’achat, soit intégrer le prix d’achat via le module dédié manuellement par appareil ou en % de la valeur neuve, conformément à une grille tarifaire ou encore à une valeur manuelle intégré par un opérateur de la direction des achats. 
Le prix d’achat se définit selon les critères suivants, dans l’ordre comme suit :
Cette première règle est prioritaire sur toutes les autres : si device_actions_budget.purchase_price_custom is not null then Achat_prix = device_actions_budget.purchase_price_custom
Ensuite voir le purchase lot du device : si sale_purchase_lot spl.device_pricing_mode = matrix then from sales_purchase_pricing_matrix, get row with:
supplier_id = spl.supplier_id
client_id = device owner organization_id
internal_grade = current_device.reception_grade (table device_action_reception)
brand_grade = current_device. brand_grade 
Si const_price is not null then Achat_prix = const_price
Si const_percent is not null then Achat_prix = const_percent * device_reference.price_new
voir le purchase lot du device : si sale_ purchase_lot spl.device_pricing_mode = fixed_price, Achat_prix = fixed_pricing_value
voir le purchase lot du device : si sale_ purchase_lot spl.device_pricing_mode = fixed_percent, Achat_prix = fixed_pricing_value * device_reference.price_new
voir le purchase lot du device : si sale_ purchase_lot spl.device_pricing_mode = service, Achat_prix = 0 (zero)

Achat_transport
Pour le calcul device_ref, moyenne des 90 derniers jours ouvrés (bien ouvrés, pas calendaires) sur ce modèle si >30 devices, uniquement sur current_organization_id et sinon sur toute la database.
Pour le calcul par appareil >> from sale_purchase_lot :
if transport_pricing_mode = fixed then Achat_transport = transport_pricing_value for each device in the lot
if transport_pricing_mode = shared then Achat_transport = transport_pricing_value / nb of devices in the lot
if transport_pricing_mode = matrix then from sales_purchase_pricing_matrix, get row with:
supplier_id = spl.supplier_id
client_id = device owner organization_id
internal_grade = current_device.reception_grade (table device_action_reception)
brand_grade = current_device. brand_grade 
Achat_transport = transport_price

Cout nettoyage
select value from organization_device_costs where device_service_sub_category_id = current device service_sub_category_id and cost=’cleaning’ and organization_id= current org_id

Cout_log_pre      // cout logistic 
const_cost_log_pre from organizations

Cout_log_post 
const_cost_log_post from organizations

Cout_palette 
select value from organization_device_costs where device_service_sub_category_id = current device service_sub_category_id and cost=’pallet’ and organization_id= current org_id

Cout_film 
select value from organization_device_costs where device_service_sub_category_id = current device service_sub_category_id and cost=’film’ and organization_id= current org_id

Cout_consommableNettoyage 
const_cost_consumables from organizations

Cout_SAV 
Cout_SAV = Taux % x Prix de vente estimé
>>  Taux  = const_cost_aftersales_rate from organizations

Cout_energie 
const_cost_energy  from organizations





Cout_diagnostic  et Cout_reparation
Ces deux couts vont être traités de manière conjointe parce qu’ils sont sourcés de la même manière. Il faut dans un premier temps calculer le temps moyen de diagnostic pour le collaborateur qui met en test l’appareil, en tenant compte de la multitude de tâche réalisée. Pour faire ça il faut le faire en plusieurs étapes. Save les résultats dans une table car on veut pouvoir analyser l’évolution.
Construire une timeline : 
Diagnostic
Début : on insert in device_action where type = Mise en test
Fin : on insert in device_action_reparations where status= Attente validation diagnostic
Owner : creator on insert in device_action_reparations where status= Attente validation diagnostic
Réparation
Début : 
Si count(*) = 0 from sparepart_requests where device_id = current_id and archived is false : le début est on insert in device_action_reparations where status= En cours de réparation
Si count(*) > 0 from sparepart_requests where device_id = current_id and archived is false : le trigger est on insert in sparepart_request_actions when count = 0 for sparepart_requests where device_id = current_id and archived is false and status != Pièce reçue and status != Pièce en stock 
Fin : on insert in device_action_reparations where status= Attente validation réparation
Owner : creator on insert in device_action_reparations where status= Attente validation réparation
Superposition des tâches par owner :
Cf Excel dans l’email. 
L’idée est que chaque minute, on regarde cb on a de tâches actives et on dispatche les 60sc de cette minute sur le nb de tâches actives. Par owner.
Bien exclure :
Les journées du weekend 
Les heures entre 16h30 et 9h 
Les jours fériés français
Minimum à 30 min par tâche.
Rendre la table visible pour contrôle/analyse

Quand faire ces calculs ?
A chaque réparation : historisation du réel du device dans table devices. Timeline c’est ici.

Résultat par device 
Réception device (étape 1) : 
Cout-diag_estimé = moyenne Cout-diag_reel sur 90 derniers jours ouvrés (bien ouvrés, pas calendaires) sur ce type de service_subcategory, uniquement sur current_organization_id et non sur toute la database
Cout-reparation_estimé = moyenne Cout-reparation_reel sur 90 derniers jours ouvrés (bien ouvrés, pas calendaires) sur ce type de service_subcategory, uniquement sur current_organization_id et non sur toute la database
Après mise en test (étape 2) :
Cout-diag_estimé = Taux horaire collaborateur réel (from users) x temps moyen diag sur 90j glissant sur ce type de service_subcategory, peu importe l’owner (toute l’équipe de organization_id)
Cout-reparation_estimé = Taux horaire collaborateur réel (from users) x temps moyen rep sur 90j glissant sur ce type de service_subcategory, peu importe l’owner (toute l’équipe de organization_id)
Après diagnostic (étape 3) :
Réel – pendant/après diag : Cout-diag_reel = Taux horaire collaborateur (from users) x temps diag réel
Après réparation (ou décision de non-réparation) (étape 4) :
Réel : Cout-reparation_reel = Taux horaire collaborateur (from users) x temps reparation réel

Marge_DN
Marge_DN = Taux % x Prix de vente estimé 
Taux = const_cost_margin_rate  from organizations

Cout_stockage
Cout_stockage estimé (stage : pre_test)
Faire moyenne sur les 180 derniers jours ouvrés (bien ouvrés, pas calendaires), sur ce type de service_subcategory, uniquement sur current_organization_id et non sur toute la database.

Sur le device, si le réel dépasse la moyenne, alors appliquer réel. (stage : après pre_test)
Cout_stockage réel = const_cost_storage from organizations x Diff[Date de Réception – Date du jour
Appareil réparé : calcul à faire jusqu’à ce que le statut passe en « Vendu »
Appareil démonté : calcul à faire jusqu’à ce que le statut passe en « Démontage terminé »


Cout_démontage 
const_cost_disassembly from organizations

Cout_pièce
Estimé
Calculé sans regarder l’org_id, mais bien toute la database.
Coût-pièce = MOYENNE[SOMME [Valeur pièces demandées]] 
Valeur pièces demandées =
Pour Doneo (org_id= bae04415-1ca9-46c2-81c8-11e39ac8ac89) : select spreq .price_new_request from sparepart_request spreq where spreq.archived is false and spreq.status = ‘Terminée’ for distinct device_id that has been refurbished (d.status=Nettoyage or d.status=Contrôle qualité or d.status=Prêt à la vente or d.status=Vendu)
Pour les autres org_id (org_id != bae04415-1ca9-46c2-81c8-11e39ac8ac89) : select spref.price_new_request from sparepart_references spref left join public.sparepart_requests spreq on spreq.sparepart_reference_id = spref.id where spreq.archived is false and spreq.status = ‘Terminée’ for distinct device_id that has been refurbished (d.status=Nettoyage or d.status=Contrôle qualité or d.status=Prêt à la vente or d.status=Vendu)
La difference est que Doneo est réaliste et considère aussi les spreq à 0€ (piochées dans le stock). Pour les autres reconditionneurs, on est conservateurs et prenons toute demande comme une commande.
Résultat :
Si au moins 30 appareils : sur le modèle (device_reference) ; 
Sinon si au moins 30 appareils : sur same brand, same device_service_subcat et same year_production group (from device_ref, mais en groupant : 0-2 ans, 3-5 ans et >5ans)
Sinon si au moins 30 appareils : sur same brand, same device_service_subcat
Sinon same device_service_subcat 

Cout_pièce_réel
Coût-pièce = SOMME [Valeur pièces commandées]] (sparepart_request. price_new_request for this device_id)

Calcul des probabilités de reconditionnement 
Historiser ces probabilités de reconditionnement (création de tables ? Dans tables actuelles ?).
Calculé sans regarder l’org_id, mais bien toute la database.
Calcul à refaire et historiser toutes les nuits (cron job).
Deux méthodologies de calcul : 
Sinon si au moins 30 appareils : sur same brand, same device_service_subcat alors : 
P (reconditionnement) = 
En synthèse : nb devices réparés / (nb devices réparés + nb devices démontés)
En détails :
Count(devices) with same brand, same device_service_subcat and exists (device_action_reparation with status = Terminé)
 / [
	Count(devices) with same brand, same device_service_subcat and exists (device_action_reparation with status = Terminé)
	+
Count(devices) with same brand, same device_service_subcat and device_action (last action) . status = Démontage terminé
]
Sinon calcul à faire que sur device_service_subcat 
Count(devices) with same device_service_subcat and exists (device_action_reparation with status = Terminé)
 / [
	Count(devices) with same device_service_subcat and exists (device_action_reparation with status = Terminé)
	+
Count(devices) with same device_service_subcat and device_action (last action) . status = Démontage terminé
]






Feedbacks Julien
Github here

03_saleprice
. Get current device quality grade (most recent) >> cette partie est à retirer je pense car on n'a pas le quality_grade de l'appareil lors du calcul et on n’en a pas besoin. Je me suis trompé dans le doc ci-dessous >> updaté en jaune, on n’a besoin QUE du reception_grade.

. Option 1 : pk ne pas mettre device_quality_grade = v_reception_grade directement dans le where du sold_devices ? Car là, j’ai l’impression qu’on sélectionne + d’appareils que nécessaire, sans les utiliser. Donc autant en sélectionner moins et ne pas refilter ensuite >> donc juste avoir SELECT COUNT(*), MIN(percent_new_price) FROM sold_devices
Qu’en dis-tu ?
>> left join lateral n’est pas très optimal donc mieux vaut faire un select ainsi et refilter

. Option 2 : idem sur device_quality_grade à éventuellement mettre directement dans le where du sold_devices et simplifier le filtre de sold_devices.

. Option 4 : merci, en effet je n’avais pas ajouté le field age (device_age).
Si tu veux simplifier la query client, tu peux considérer que client_id = current org_id. J’ai construit le truc comme ça pour simplifier les miennes, histoire de dire que la grille de pricing théorique est la seule avec supplier_id = client_id = org_id. Donc suppr c.name et c.owner_id et juste garder c.id
sppm.brand_grade = v_brand_grade; doit disparaitre et être remplacé par sppm.device_age = l’age du device (current_year MINUS year from devices_ref); If >10 then consider sppm.device_age=10
sppm.internal_grade = COALESCE(v_quality_grade, v_reception_grade) >> doit être simplement sppm.internal_grade = v_reception_grade

04 et 05
Transport et purchase sont très liés, pk les avoir séparés ? 
>> On aurait pu, à faire p-e plus tard

07 device_budget
. IF v_price_new IS NULL OR v_price_new <= 0 THEN >> inclure aussi : and year_production is not null and brand_id is not null and device_service_sub_category_id is not null

. Trigger ‘Abandon - démontage’ doit être : 
Soit ilike ‘Abandon - démontage’ 
Soit =’Abandon - démontage (diagnostic)’ or =’Abandon - démontage (réparation)’

. Il manque le trigger de quand : 
On a une reception avec devices_references.price_new is null or year or brand or service_subcat >> le calcul ne se lance pas
Lorsque les datas devices_references sont saisies, il faut lancer le calcul sur chacun des devices de ce device_ref. 
>> Est-ce que le trigger est : 
on_update_device_ref ?
ou est-ce que l’update device_ref trigger un insert dans device_actions (avec par ex type=’Modification appareil’) et donc on crée un nouveau trigger dans ton script pour device_actions=’Modification appareil’ ?

. pre_test : AND EXTRACT(DOW FROM da.created_at) BETWEEN 1 AND 5;
Je ne suis pas sur de moi, mais j’ai l’impression que ça ne fait qu’exclure les weekends, mais ça ne transorme pas la daterange en 90j ouvrés (lundi-vendredi), non ? 
Si j’ai raison, ce n’est pas dramatique et retirons cette partie, c’est du détail et 90j iront très bien.

. post_diag : 
Trigger est en fait ‘Attente validation diagnostic’, désolé, erreur de ma part >> corrigée en jaune ci-dessus
diag_duration est ok ainsi pour le moment, ensuite on remplacera par les fameuses timelines, qu’on doit faire après.
A FAIRE HAMZA : v_storage_cost = 0 : pk ? Cf explications dans la partie dédiée ci-dessus.
A FAIRE HAMZA (timelines) : dab.diagnostic_cost est incorrect. Désormais c’est le temps réel : 
Durée diag réelle : NOW MINUS device_actions.created_at where type=Mise en test * u.hourly_cost

.  'repaired'
A FAIRE HAMZA : v_storage_cost 
A FAIRE HAMZA (timelines) : dab.repair_costest incorrect. Désormais c’est le temps réel : 
Durée réparation réelle : NOW MINUS device_actions_reparation.created_at where status=En cours de réparation
* u.hourly_cost

.  'deee' THEN
A FAIRE HAMZA : v_storage_cost 

. WHEN 'final_repaired', 'final_deee' THEN
v_storage_cost : pas *0.35 mais * const_cost_storage from organizations. Dsl, oubli de ma part, rajouté ci-dessus + dans la table.

Question générale
Une différence entre « archived is false » (que j’utilise) et « archived = false » (que tu utilises) ?
>> mieux is
